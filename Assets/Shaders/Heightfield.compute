#pragma kernel updateHeightfield

struct HeightField {
	float height;
	float velocity;
};

float g_fSpeed;			//	speed of the waves
float g_fDamping;
float g_fMaxVelocity;
float g_fDeltaTime;		//	timeStep
float g_fMaxHeight;
float g_fGridSpacing;
float g_fQuadSize;		//	size of the quads of the mesh
float g_fAvgHeight;		//	avgerage height, computed on CPU
uint g_iDepth;			//	depth of the heightfield
uint g_iWidth;			//	width "-"

RWStructuredBuffer<HeightField> heightFieldOut : register(u0);
StructuredBuffer<HeightField> heightFieldIn : register(t0);

[numthreads(16, 16, 1)]
void updateHeightfield(uint3 id : SV_DispatchThreadID)
{
	//	https://www.cs.ubc.ca/~rbridson/fluidsimulation/GameFluids2007.pdf
	//	http://matthias-mueller-fischer.ch/talks/GDC2008.pdf

	//	get corresponding indices of current thread
	int i = id.x;
	int j = id.y;

	if (i >= g_iWidth || j >= g_iDepth)
		return;

	//	let c be g_fSpeed, 
	//	v[i, j]_t the velocity of the heightfield at position i, j at timeStep t, 
	//	h[i,j]_t equivalent

	//	wave equation in 2D, semi-implicit euler
	//	max and min used for clamping the boundary and reflecting the waves
	//	v[i, j]_(t+1) = v_t + dt * c * c * ((h[i - 1, j] + h[i + 1, j] + h[i, j + 1] + h[i, j - 1])- 4 * h[i, j]_t)	/ (g_fGridSpacing * g_fGridSpacing)

	heightFieldOut[i * g_iDepth + j].velocity = heightFieldIn[i * g_iDepth + j].velocity + g_fDeltaTime * g_fSpeed * g_fSpeed *
		((heightFieldIn[max(i - 1, 0) * g_iDepth + j].height + heightFieldIn[min(g_iWidth - 1, i + 1) * g_iDepth + j].height
			+ heightFieldIn[i * g_iDepth + max(j - 1, 0)].height + heightFieldIn[i * g_iDepth + min(g_iDepth - 1, min(j + 1, g_iDepth - 1))].height)
			- 4 * (heightFieldIn[i * g_iDepth + j].height)) / (g_fGridSpacing * g_fGridSpacing);

	//	clamping and damping of velocity
	heightFieldOut[i * g_iDepth + j].velocity = clamp(heightFieldOut[i * g_iDepth + j].velocity, -g_fMaxVelocity, g_fMaxVelocity);
	heightFieldOut[i * g_iDepth + j].velocity *= g_fDamping;

	//	integrate height at timestep t+1:  h[i,j]_t+1 = h[i,j]_t + v[i,j]_t * dt 
	heightFieldOut[i * g_iDepth + j].height = heightFieldIn[i*g_iDepth + j].height + heightFieldOut[i * g_iDepth + j].velocity * g_fDeltaTime;

	//	keep average Height of all points at ca. 0
	heightFieldOut[i * g_iDepth + j].height -= g_fAvgHeight;

	//	clamp height
	heightFieldOut[i * g_iDepth + j].height = clamp(heightFieldOut[i * g_iDepth + j].height, -g_fMaxHeight, g_fMaxHeight);
}